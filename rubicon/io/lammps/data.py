# coding: utf-8

from __future__ import division, print_function, unicode_literals, \
    absolute_import

"""
This module implements classes for generating Lammps data files.
TODO: add unittests
"""

import six
from six.moves import range
from six.moves import zip
from io import open
import math

from pymatgen.core.structure import Molecule, Structure

from rubicon.io.amber.antechamber import AntechamberRunner

__author__ = 'Kiran Mathew, Navnidhi Rajput'


class LammpsData(object):
    """
    Write the lammps data file for the given molecule and box size.
    The default data file format corresponds to atom_style = atomic. If the
    molecule has the "charge" site property then the data file will be written
    in the format that corresponds to atom_style = charge

    Args:
        molecule (Molecule): molecule
        box_size (list): size of the box that embeds the packed molecule.
            [x_min, y_min, z_min, x_max, y_max, z_max]
    """

    def __init__(self, molecule, box_size):
        self.box_size = box_size
        box_lengths = [box_size[dim + 3] - box_size[dim] for dim in range(3)]
        self.boxed_molecule = None
        self.atoms_data = []
        # be defensive about the box size
        if isinstance(molecule, Molecule):
            self.boxed_molecule = molecule.get_boxed_structure(*box_lengths)
        elif isinstance(molecule, Structure):
            max_length = max(self.boxed_molecule.lattice.abc)
            max_box_size = max(box_lengths)
            self.boxed_molecule = Molecule.from_sites(self.boxed_molecule.sites)
            if max_length < max_box_size:
                self.boxed_molecule = \
                    self.boxed_molecule.get_boxed_structure(*box_lengths)
            else:
                self.boxed_molecule = \
                    self.boxed_molecule.get_boxed_structure(max_length,
                                                            max_length, max_length)
        else:
            raise ValueError("molecule must be an object of Molecule or "
                             "Structure ")
        self._set_basic_system_info()
        self._set_atoms_data()

    def _set_basic_system_info(self):
        """
        basic system info such as number of atoms, atom types, masses and
        box size
        """
        self.natoms = len(self.boxed_molecule)
        self.natom_types = len(self.boxed_molecule.symbol_set)
        self.box_size = [0, self.boxed_molecule.lattice.a, 0,
                         self.boxed_molecule.lattice.b, 0,
                         self.boxed_molecule.lattice.c]
        self.atomic_masses = [[i+1, site.specie.data["Atomic mass"]]
                              for i, site in enumerate(self.boxed_molecule)]

    def _set_atoms_data(self):
        """
        atoms data:
        atom_id, atom_type, charge(if present), x, y, z
        """
        for i, site in enumerate(self.boxed_molecule):
            atom_type = self.boxed_molecule.symbol_set.index(
                site.species_string)
            if hasattr(site, "charge"):
                self.atoms_data.append([i + 1, atom_type + 1, site.charge,
                                        site.x, site.y, site.z])
            else:
                self.atoms_data.append([i + 1, atom_type + 1, site.x,
                                        site.y, site.z])

    @staticmethod
    def set_lines_from_list(lines, block_name, input_list):
        """
        append paramter coefficient and paramter data values to the lines list
        """
        lines.append("\n" + block_name + " \n")
        _ = [lines.append(" ".join([str(x) for x in ad])) for ad in input_list]

    def __str__(self):
        """
        string representation of LammpsData
        """
        lines = []
        lines.append("Data file generated by rubicon\n")
        lines.append("{} atoms\n".format(self.natoms))
        lines.append("{} atom types\n".format(self.natom_types))
        lines.append("{} {} xlo xhi\n{} {} ylo yhi\n{} {} zlo zhi".format(
            *self.box_size))
        self.set_lines_from_list(lines, "Masses", self.atomic_masses)
        self.set_lines_from_list(lines, "Atoms", self.atoms_data)
        return '\n'.join(lines)

    def write_data_file(self, filename):
        """
        write lammps data input file
        """
        with open(filename, 'w') as f:
            f.write(self.__str__())


class LammpsForceFieldData(LammpsData):
    """
    Sets Lammps data input file from force field parameters

    Args:
        mols (list): list of Molecule objects
        mols_number (list): list of number of each type of molecule in mols
            list
        box_size (list): size of the box that embeds the packed molecule.
            [x_min, y_min, z_min, x_max, y_max, z_max]
        molecule (Molecule): the molecule generated from the molecules in mols list with
            the numbers from mols_number list(Packmol can be used to generate the molecule)
        forcefield (ForceField): force field parameters
        topologies (list): list of Topology objects for each molecule in mols
    """

    def __init__(self, mols, mols_number, box_size, molecule, forcefield, topologies):
        self.mols = mols
        self.mols_number = mols_number
        self.box_size = box_size
        self.molecule = molecule
        self.forcefield = forcefield
        self.topologies = topologies
        super(LammpsForceFieldData, self).__init__(self.molecule, self.box_size)
        # system stats
        self.nbond_types = 0
        self.nangle_types = 0
        self.ndih_types = 0
        self.nimdih_types = 0
        self.ndih = 0
        self.nbonds = 0
        self.nangles = 0
        self.nimdihs = 0
        # coefficients and maps
        self.bond_coeffs = []
        self.pair_coeffs = []
        self.angle_coeffs = []
        self.dihedral_coeffs = []
        self.improper_coeffs = []
        self.bond_map = {}
        self.angles_map = {}
        self.dihedral_map = {}
        self.imdihedral_map = {}
        # data
        self.atoms_data = []
        self.bonds_data = []
        self.angles_data = []
        self.dihedrals_data = []
        self.imdihedrals_data = []
        # set the system info, parameter coefficients and the parameter data
        self._set_system_info()
        self._set_coeffs()
        self._set_data()

    def _set_system_info(self):
        """
        set the system information. It comprises of the number of atoms,
        number of molecules, box size, number of bond types/bonds, number of
        angle types/angles, number of dihedral types/dihedrals and the
        number of improper dihedral types/improper dihedrals.
        """
        self.nbond_types = len(self.forcefield.bonds)
        self.nangle_types = len(self.forcefield.angles)
        if self.forcefield.dihedrals:
            self.ndih_types = len(self.forcefield.dihedrals)
        if self.forcefield.imdihedrals:
            self.nimdih_types = len(self.forcefield.imdihedrals)
        for mol_type, top in enumerate(self.topologies):
            self.nbonds += len(top.bonds) * self.mols_number[mol_type]
            self.nangles += len(top.angles) * self.mols_number[mol_type]
            if top.dihedrals:
                self.ndih += len(top.dihedrals) * self.mols_number[mol_type]
            if top.imdihedrals:
                self.nimdihs += len(top.imdihedrals) * self.mols_number[mol_type]

    def _set_coeffs(self):
        """
        set the coefficients for pair potentials, bonds, angles and dihedrals using the force
        field object.
        Also sets up the map between the molecule type in self.mols list and the
        parameter type and the parameter label.
        For example: bond_map maps each molecule type to {bond_key(or label) : unique bond number}
        i.e {mol_type: {bond_key : unique bond number}}.

        note: mol_type starts from 0
        """
        bond_id_offset = 0
        angle_id_offset = 0
        vdw_id_offset = 0
        dih_id_offset = 0
        imdih_id_offset = 0
        for mol_type in range(len(self.mols)):
            self.bond_coeffs, self.bond_map[mol_type] = \
                self._get_param_coeff("bonds", bond_id_offset)
            self.angle_coeffs, self.angles_map[mol_type] = \
                self._get_param_coeff("angles", angle_id_offset)
            self.pair_coeffs, _ = \
                self._get_param_coeff("vdws", vdw_id_offset)
            if self.ndih_types > 0:
                self.dihedral_coeffs, self.dihedral_map[mol_type] = \
                    self._get_param_coeff("dihedrals", dih_id_offset)
            if self.nimdih_types > 0:
                self.improper_coeffs, self.imdihedral_map[mol_type] = \
                    self._get_param_coeff("imdihedrals", imdih_id_offset)

    def _get_param_coeff(self, param_name, offset):
        """
        get the parameter coefficients from the force field

        Args:
            param_name (str): name of the parameter for which the coefficient are to be set.
            offset (int): the offset used to assign a unique id(starting from 0) to each
                parameter value

        Returns:
            [[unique paramter id, parameter values, ... ], ... ] and
            {paramter key: parameter id,...]}
        """
        if hasattr(self.forcefield, param_name):
            mapping = {}
            param = getattr(self.forcefield, param_name)
            param_coeffs = []
            param_id_offset = offset
            if param:
                for i, param_vals in enumerate(param.values()):
                    param_id = param_id_offset + i
                    param_coeffs.append([param_id+1] + list(param_vals))
                    mapping[param.keys()[i]] = param_id
                offset += len(param)
            return param_coeffs, mapping
        else:
            raise AttributeError

    def _set_data(self):
        """
        set atoms, bonds, angles and dihedral data
        """
        self._set_atoms_data()
        self.bonds_data = self._get_param_data("bonds", self.bond_map)
        self.angles_data = self._get_param_data("angles", self.angles_map)
        if self.ndih > 0:
            self.dihedrals_data = self._get_param_data("dihedrals", self.dihedral_map)
        if self.nimdihs:
            self.imdihedrals_data = self._get_param_data("imdihedral", self.imdihedral_map)

    def _set_atoms_data(self):
        """
        set the atoms data:
        [atom id, mol type, atom type, charge, x, y, z]
        where atom id is the global atom id, mol type is the type of the
        molecule(from mols list).
        Also sets up the maps 'atom_to_mol' and 'atom_to_global_molid'.
        'atom_to_mol' --> { global atom id : [ mol type, local atom id], ... }.
        'molid_to_atomid' --> [ [gloabal atom id 1, id 2, ..], ...], the index will
        be the global mol id
        """
        self.atom_to_mol = {}
        self.molid_to_atomid = []
        nmols = len(self.mols)
        shift = [0] + [len(self.mols[i]) * self.mols_number[i] for i in range(nmols - 1)]
        # set up map atom_id --> [mol_type, local atom id in the mol] in self.mols
        # set up map gobal molecule id --> [[atom_id,...],...]
        for mol_type in range(nmols):
            natoms = len(self.mols[mol_type])
            for num_mol_id in range(self.mols_number[mol_type]):
                tmp = []
                for mol_atom_id in range(natoms):
                    atom_id = num_mol_id * natoms + mol_atom_id + shift[mol_type]
                    self.atom_to_mol[atom_id] = [mol_type, mol_atom_id]
                    tmp.append(atom_id)
                self.molid_to_atomid.append(tmp)
        # set atoms data from the final molecule assembly(the packed molecule
        # obtained from packmol using the molecules from mols list and the
        # molecule numbers from mol_number list).
        # atom id, mol id, atom type, charge from topology, x, y, z
        for i, site in enumerate(self.molecule):
            atom_type = self.molecule.symbol_set.index(
                site.species_string) + 1
            atom_id = i + 1
            mol_type = self.atom_to_mol[i][0] + 1
            mol_atom_id = self.atom_to_mol[i][1] + 1
            charge = 0.0
            if hasattr(self.topologies[0], "charges"):
                if self.topologies[mol_type - 1].charges:
                    charge = self.topologies[mol_type - 1].charges[mol_atom_id - 1][0]
            self.atoms_data.append([atom_id, mol_type, atom_type, charge,
                                    site.x, site.y, site.z])

    def _get_param_data(self, param_name, param_map):
        """
        set the data for the parameter named param_name

        Args:
            param_name (str): parameter name, example: "bonds"
            param_map (dict): { mol_type: {parameter_key : unique global parameter id, ... }, ... }
                example: {0: {("c1","c2"): 1}} ==> c1-c2 bond in mol_type=0 has the global id of 1

        Returns:
            [parameter id, parameter type, global atom id1, global atom id2, ...]
        """
        nmols = len(self.mols)
        shift = [0] + [len(self.mols[i]) * self.mols_number[i] for i in range(nmols - 1)]
        mol_id = 0
        # set the map param_to_mol:
        # {global param_id :[global mol id, mol_type, local param id in the param], ... }
        param_to_mol = {}
        for mol_type in range(nmols):
            param_obj = getattr(self.topologies[mol_type], param_name)
            nparams = len(param_obj)
            for num_mol_id in range(self.mols_number[mol_type]):
                mol_id += 1
                for mol_param_id in range(nparams):
                    param_id = num_mol_id * nparams + mol_param_id + shift[mol_type]
                    param_to_mol[param_id] = [mol_id - 1, mol_type, mol_param_id]
        # set the parameter data using the topology info
        # example: loop over all bonds in the system
        param_data = []
        for param_id, pinfo in param_to_mol.items():
            mol_id = pinfo[0] # global molecule id
            mol_type = pinfo[1] # type of molecule
            mol_param_id = pinfo[2] # local parameter id in that molecule
            # example: get the bonds list for mol_type molecule
            param_obj = getattr(self.topologies[mol_type], param_name)
            # connectivity info(local atom ids and type) for the parameter with the local id
            # 'mol_param_id'. example: single bond = [i, j, bond_type]
            param = param_obj[mol_param_id]
            param_atomids = []
            # loop over local atom ids that constitute the parameter for the molecule type, mol_type
            # example: single bond = [i,j,bond_label]
            for atomid in param[:-1]:
                # local atom id to global atom id
                global_atom_id = self.molid_to_atomid[mol_id][atomid-1]
                param_atomids.append(global_atom_id+1)
            param_type = param[-1]
            # example: get the unique number id for the bond_type
            param_type_id = param_map[mol_type][param_type]
            param_data.append([param_id+1, param_type_id+1] + param_atomids)
        return param_data

    def __str__(self):
        """
        returns a string of lammps data input file
        """
        lines = []
        # title
        lines.append("Data file generated by rubicon\n")
        # count
        lines.append("{} atoms".format(self.natoms))
        lines.append("{} bonds".format(self.nbonds))
        lines.append("{} angles".format(self.nangles))
        lines.append("{} dihedrals".format(self.ndih))
        lines.append("{} impropers\n".format(self.nimdihs))
        # types
        lines.append("{} atom types".format(self.natom_types))
        lines.append("{} bond types".format(self.nbond_types))
        lines.append("{} angle types".format(self.nangle_types))
        lines.append("{} dihedral types".format(self.ndih_types))
        lines.append("{} improper types\n".format(self.nimdih_types))
        # box size
        lines.append("{} {} xlo xhi\n{} {} ylo yhi\n{} {} zlo zhi".format(*self.box_size))
        # masses
        self.set_lines_from_list(lines, "Masses", self.atomic_masses)
        # coefficients
        self.set_lines_from_list(lines, "Pair Coeffs", self.pair_coeffs)
        self.set_lines_from_list(lines, "Bond Coeffs", self.bond_coeffs)
        self.set_lines_from_list(lines, "Angle Coeffs", self.angle_coeffs)
        self.set_lines_from_list(lines, "Dihedral Coeffs", self.dihedral_coeffs)
        self.set_lines_from_list(lines, "Improper Coeffs", self.improper_coeffs)
        # data
        self.set_lines_from_list(lines, "Atoms", self.atoms_data)
        self.set_lines_from_list(lines, "Bonds", self.bonds_data)
        self.set_lines_from_list(lines, "Angles", self.angles_data)
        self.set_lines_from_list(lines, "Dihedrals", self.dihedrals_data)
        self.set_lines_from_list(lines, "Impropers", self.imdihedrals_data)
        return '\n'.join(lines)

    @staticmethod
    def from_amber(mols, mols_number, box_size, packed_molecule, gaussian_files):
        """
        WARNING: The antechamber interface is messed up.

        Use the gaussian output file and the Antechamber tool to generate the
        force field and the topology data for the lammps calculation.

        Args:
            gaussian_files (list): list of gaussian output filenames, one for each molecule
                in the mols list.
        """
        acr = AntechamberRunner(mols)
        amber_ffs = acr.get_gaussian_ff_top(gaussian_files)
        topologies = [amber_ff.topology for amber_ff in amber_ffs]
        forcefields = [amber_ff.force_field for amber_ff in amber_ffs]
        return LammpsForceFieldData(mols, mols_number, box_size, packed_molecule, forcefields,
                                    topologies)
