# coding: utf-8

from __future__ import division, print_function, unicode_literals, \
    absolute_import

"""
This module implements classes for generating Lammps data files.
TODO: add unittests
"""

from six.moves import range
from io import open
import re

from pymatgen.core.structure import Molecule, Structure

from rubicon.io.amber.antechamber import AntechamberRunner

__author__ = 'Kiran Mathew'
__credits__ = 'Navnidhi Rajput'
__email__ = "kmathew@lbl.gov"


class LammpsData(object):
    """
    Basic Lammps data: just the atoms section

    Args:
        box_size (list): [[x_min, x_max],[y_min,y_max],[z_min,z_max]]
        atomic_masses (list): [[atom type, mass],...]
        atoms_data (list): [[atom id, mol id, atom type, charge, x, y, z ...], ... ]
    """

    def __init__(self, box_size, atomic_masses, atoms_data):
        self.box_size = box_size
        self.natoms = len(atoms_data)
        self.natom_types =len(atomic_masses)
        self.atomic_masses = atomic_masses
        self.atoms_data = atoms_data

    def __str__(self):
        """
        string representation of LammpsData
        """
        lines = []
        lines.append("Data file generated by rubicon\n")
        lines.append("{} atoms\n".format(self.natoms))
        lines.append("{} atom types\n".format(self.natom_types))
        lines.append("{} {} xlo xhi\n{} {} ylo yhi\n{} {} zlo zhi".format(
            *self.box_size))
        self.set_lines_from_list(lines, "Masses", self.atomic_masses)
        self.set_lines_from_list(lines, "Atoms", self.atoms_data)
        return '\n'.join(lines)

    def write_data_file(self, filename):
        """
        write lammps data input file
        """
        with open(filename, 'w') as f:
            f.write(self.__str__())

    @staticmethod
    def _get_basic_system_info(structure):
        """
        basic system info such as number of atoms, atom types, masses and
        box size
        """
        natoms = len(structure)
        natom_types = len(structure.symbol_set)
        box_size = [0, structure.lattice.a, 0,
                    structure.lattice.b, 0,
                    structure.lattice.c]
        atomic_masses = [[i+1, site.specie.data["Atomic mass"]]
                              for i, site in enumerate(structure)]
        return natoms, natom_types, box_size, atomic_masses

    @staticmethod
    def _get_atoms_data(structure):
        """
        atoms data:
        atom_id, atom_type, charge(if present), x, y, z
        """
        atoms_data = []
        for i, site in enumerate(structure):
            atom_type = structure.symbol_set.index(
                site.species_string)
            if hasattr(site, "charge"):
                atoms_data.append([i + 1, atom_type + 1, site.charge,
                                        site.x, site.y, site.z])
            else:
                atoms_data.append([i + 1, atom_type + 1, site.x,
                                        site.y, site.z])
        return atoms_data

    @staticmethod
    def set_lines_from_list(lines, block_name, input_list):
        """
        append paramter coefficient and paramter data values to the lines list
        """
        lines.append("\n" + block_name + " \n")
        _ = [lines.append(" ".join([str(x) for x in ad])) for ad in input_list]

    @staticmethod
    def from_structure(input_structure, box_size):
        structure = get_boxed_molecule(input_structure, box_size)
        natoms, natom_types, box_size, atomic_masses = LammpsData._get_basic_system_info(structure)
        atoms_data = LammpsData._get_atoms_data(structure)
        return LammpsData(box_size, atomic_masses, atoms_data)

    @staticmethod
    def from_file(data_file):
        """
        parse lammps data file
        """
        atomic_masses = []  # atom_type(starts from 1): mass
        box_size = []
        atoms_data = []
        atoms_pattern = re.compile("^\s*(\d+)\s+(\d+)\s+(\d+)\s+([0-9eE\.+-]+)\s+("
                                   "[0-9eE\.+-]+)\s+([0-9eE\.+-]+)\w*")
        masses_pattern = re.compile("^\s*(\d+)\s+([0-9\.]+)$")
        box_pattern = re.compile("^([0-9\.-]+)\s+([0-9\.-]+)\s+[x,y,z]lo\s+[x,y,z]hi")
        with open(data_file) as df:
            for line in df:
                if masses_pattern.search(line):
                    m = masses_pattern.search(line)
                    atomic_masses.append(float(m.group(2)))
                if box_pattern.search(line):
                    m = box_pattern.search(line)
                    box_size.append([m.group(1), m.group(2)])
                m = atoms_pattern.search(line)
                if m:
                    # atom id, mol id, atom type
                    line_data = [int(i) for i in m.groups()[:3] ]
                    # charge, x, y, z, vx, vy, vz ...
                    line_data.extend([float(i) for i in m.groups()[3:] ])
                    atoms_data.append(line_data)
        natoms = len(atoms_data)
        natom_types = len(atomic_masses)
        return LammpsData(natoms, natom_types, atomic_masses, atoms_data)


class LammpsForceFieldData(LammpsData):
    """
    Sets Lammps data input file from force field parameters

    Args:
        mols (list): list of Molecule objects
        mols_number (list): list of number of each type of molecule in mols
            list
        box_size (list): size of the box that embeds the packed molecule.
            [x_min, y_min, z_min, x_max, y_max, z_max]
        molecule (Molecule): the molecule generated from the molecules in mols list with
            the numbers from mols_number list(Packmol can be used to generate the molecule)
        forcefield (ForceField): force field parameters
        topologies (list): list of Topology objects for each molecule in mols
    """

    def __init__(self, box_size, atomic_masses, pair_coeffs, bond_coeffs, angle_coeffs,
                 dihedral_coeffs, improper_coeffs, atoms_data, bonds_data, angles_data,
                 dihedrals_data, imdihedrals_data):
        self.natom_types = len(atomic_masses)
        self.nbond_types = len(bond_coeffs)
        self.nangle_types = len(angle_coeffs)
        self.ndih_types = len(dihedral_coeffs)
        self.nimdih_types = len(improper_coeffs)
        self.natoms = len(atoms_data)
        self.nbonds = len(bonds_data)
        self.nangles = len(angles_data)
        self.ndih = len(dihedrals_data)
        self.nimdihs = len(imdihedrals_data)
        self.box_size = box_size
        self.atomic_masses = atomic_masses
        self.pair_coeffs = pair_coeffs
        self.bond_coeffs = bond_coeffs
        self.angle_coeffs = angle_coeffs
        self.dihedral_coeffs = dihedral_coeffs
        self.improper_coeffs = improper_coeffs
        self.atoms_data = atoms_data
        self.bonds_data = bonds_data
        self.angles_data = angles_data
        self.dihedrals_data = dihedrals_data
        self.imdihedrals_data = imdihedrals_data

    def __str__(self):
        """
        returns a string of lammps data input file
        """
        lines = []
        # title
        lines.append("Data file generated by rubicon\n")

        # count
        lines.append("{} atoms".format(self.natoms))
        lines.append("{} bonds".format(self.nbonds))
        lines.append("{} angles".format(self.nangles))
        if self.ndih > 0:
            lines.append("{} dihedrals".format(self.ndih))
        if self.nimdihs > 0:
            lines.append("{} impropers".format(self.nimdihs))

        # types
        lines.append("\n{} atom types".format(self.natom_types))
        lines.append("{} bond types".format(self.nbond_types))
        lines.append("{} angle types".format(self.nangle_types))
        if self.ndih > 0:
            lines.append("{} dihedral types".format(self.ndih_types))
        if self.nimdihs > 0:
            lines.append("{} improper types".format(self.nimdih_types))

        # box size
        lines.append("\n{} {} xlo xhi\n{} {} ylo yhi\n{} {} zlo zhi".format(*self.box_size))

        # masses
        self.set_lines_from_list(lines, "Masses", self.atomic_masses)

        # coefficients
        self.set_lines_from_list(lines, "Pair Coeffs", self.pair_coeffs)
        self.set_lines_from_list(lines, "Bond Coeffs", self.bond_coeffs)
        self.set_lines_from_list(lines, "Angle Coeffs", self.angle_coeffs)
        if self.ndih > 0:
            self.set_lines_from_list(lines, "Dihedral Coeffs", self.dihedral_coeffs)
        if self.nimdihs > 0:
            self.set_lines_from_list(lines, "Improper Coeffs", self.improper_coeffs)

        # data
        self.set_lines_from_list(lines, "Atoms", self.atoms_data)
        self.set_lines_from_list(lines, "Bonds", self.bonds_data)
        self.set_lines_from_list(lines, "Angles", self.angles_data)
        if self.ndih > 0:
            self.set_lines_from_list(lines, "Dihedrals", self.dihedrals_data)
        if self.nimdihs > 0:
            self.set_lines_from_list(lines, "Impropers", self.imdihedrals_data)
        return '\n'.join(lines)

    @staticmethod
    def get_param_coeff(forcefield, param_name):
        """
        get the parameter coefficients from the force field

        Args:
            param_name (str): name of the parameter for which the coefficients
                are to be set.
            offset (int): the offset used to assign a unique id(starting from 0)
                to each parameter value

        Returns:
            [[unique paramter id, parameter values, ... ], ... ] and
            {paramter key: parameter id,...]}
        """
        if hasattr(forcefield, param_name):
            param = getattr(forcefield, param_name)
            param_coeffs = []
            if param:
                for i, param_vals in enumerate(param.values()):
                    param_coeffs.append(list(param_vals))
            return param_coeffs
        else:
            raise AttributeError

    @staticmethod
    def get_param_mapping(param, mols):
        """
        get the parameter coefficients from the force field

        Args:
            param_name (str): name of the parameter for which the coefficients
                are to be set.
            offset (int): the offset used to assign a unique id(starting from 0)
                to each parameter value

        Returns:
            [[unique paramter id, parameter values, ... ], ... ] and
            {paramter key: parameter id,...]}
        """
        mapping = {}
        tmp = {}
        offset =0
        for mol_type in range(len(mols)):
            param_id_offset = offset
            for i, k in enumerate(param.keys()):
                param_id = param_id_offset + i
                tmp[k] = param_id
            offset += len(param)
            mapping[mol_type] = tmp
        return mapping

    @staticmethod
    def get_atoms_data(mols, mols_number, molecule, topologies):
        """
        set the atoms data:
        [atom id, mol type, atom type, charge, x, y, z]
        where atom id is the global atom id, mol type is the type of the
        molecule(from mols list).
        Also sets up the maps 'atom_to_mol' and 'atom_to_global_molid'.
        'atom_to_mol' --> { global atom id : [ mol type, local atom id], ... }.
        'molid_to_atomid' --> [ [gloabal atom id 1, id 2, ..], ...], the index will
        be the global mol id
        """
        atom_to_mol = {}
        molid_to_atomid = []
        atoms_data = []
        nmols = len(mols)
        shift = [0] + [len(mols[i]) * mols_number[i] for i in range(nmols - 1)]
        # set up map atom_id --> [mol_type, local atom id in the mol] in self.mols
        # set up map gobal molecule id --> [[atom_id,...],...]
        for mol_type in range(nmols):
            natoms = len(mols[mol_type])
            for num_mol_id in range(mols_number[mol_type]):
                tmp = []
                for mol_atom_id in range(natoms):
                    atom_id = num_mol_id * natoms + mol_atom_id + shift[mol_type]
                    atom_to_mol[atom_id] = [mol_type, mol_atom_id]
                    tmp.append(atom_id)
                molid_to_atomid.append(tmp)
        # set atoms data from the final molecule assembly(the packed molecule
        # obtained from packmol using the molecules from mols list and the
        # molecule numbers from mol_number list).
        # atom id, mol id, atom type, charge from topology, x, y, z
        for i, site in enumerate(molecule):
            atom_type = molecule.symbol_set.index(
                site.species_string) + 1
            atom_id = i + 1
            mol_type = atom_to_mol[i][0] + 1
            mol_atom_id = atom_to_mol[i][1] + 1
            charge = 0.0
            if hasattr(topologies[0], "charges"):
                if topologies[mol_type - 1].charges:
                    charge = topologies[mol_type - 1].charges[mol_atom_id - 1][0]
            atoms_data.append([atom_id, mol_type, atom_type, charge,
                                    site.x, site.y, site.z])
        return atoms_data, molid_to_atomid

    @staticmethod
    def get_param_data(param_name, param_map, mols, mols_number, topologies, molid_to_atomid):
        """
        set the data for the parameter named param_name

        Args:
            param_name (str): parameter name, example: "bonds"
            param_map (dict): { mol_type: {parameter_key : unique global parameter id, ... }, ... }
                example: {0: {("c1","c2"): 1}} ==> c1-c2 bond in mol_type=0 has the global id of 1

        Returns:
            [parameter id, parameter type, global atom id1, global atom id2, ...]
        """
        nmols = len(mols)
        shift = [0] + [len(mols[i]) * mols_number[i] for i in range(nmols - 1)]
        mol_id = 0
        # set the map param_to_mol:
        # {global param_id :[global mol id, mol_type, local param id in the param], ... }
        param_to_mol = {}
        for mol_type in range(nmols):
            param_obj = getattr(topologies[mol_type], param_name)
            nparams = len(param_obj)
            for num_mol_id in range(mols_number[mol_type]):
                mol_id += 1
                for mol_param_id in range(nparams):
                    param_id = num_mol_id * nparams + mol_param_id + shift[mol_type]
                    param_to_mol[param_id] = [mol_id - 1, mol_type, mol_param_id]
        # set the parameter data using the topology info
        # example: loop over all bonds in the system
        param_data = []
        for param_id, pinfo in param_to_mol.items():
            mol_id = pinfo[0]  # global molecule id
            mol_type = pinfo[1]  # type of molecule
            mol_param_id = pinfo[2]  # local parameter id in that molecule
            # example: get the bonds list for mol_type molecule
            param_obj = getattr(topologies[mol_type], param_name)
            # connectivity info(local atom ids and type) for the parameter with the local id
            # 'mol_param_id'. example: single bond = [i, j, bond_type]
            param = param_obj[mol_param_id]
            param_atomids = []
            # loop over local atom ids that constitute the parameter
            # for the molecule type, mol_type
            # example: single bond = [i,j,bond_label]
            for atomid in param[:-1]:
                # local atom id to global atom id
                global_atom_id = molid_to_atomid[mol_id][atomid-1]
                param_atomids.append(global_atom_id+1)
            param_type = param[-1]
            # example: get the unique number id for the bond_type
            param_type_id = param_map[mol_type][param_type]
            param_data.append([param_id+1, param_type_id+1] + param_atomids)
        return param_data

    @staticmethod
    def from_forcefield_and_topology(mols, mols_number, box_size, molecule, forcefield,
                                     topologies):
        # set the coefficients from the force field
        bond_coeffs = LammpsForceFieldData.get_param_coeff(forcefield, "bonds")
        bond_map = LammpsForceFieldData.get_param_mapping(forcefield.bonds, mols)
        angle_coeffs = LammpsForceFieldData.get_param_coeff(forcefield, "angles")
        angle_map = LammpsForceFieldData.get_param_mapping(forcefield.angles, mols)
        pair_coeffs = LammpsForceFieldData.get_param_coeff(forcefield, "vdws")
        dihedral_coeffs = LammpsForceFieldData.get_param_coeff(forcefield, "dihedrals")
        dihedral_map = LammpsForceFieldData.get_param_mapping(forcefield.dihedrals, mols)
        improper_coeffs = LammpsForceFieldData.get_param_coeff(forcefield, "imdihedrals")
        imdihedral_map = LammpsForceFieldData.get_param_mapping(forcefield.imdihedrals, mols)
        # atoms data
        atoms_data, molid_to_atomid = LammpsForceFieldData.get_atoms_data(mols, mols_number, molecule, topologies)
        # set the other data
        bonds_data = LammpsForceFieldData.get_param_data("bonds", bond_map, mols, mols_number,
                                         topologies, molid_to_atomid)
        angles_data = LammpsForceFieldData.get_param_data("angles", angle_map, mols, mols_number,
                                          topologies, molid_to_atomid)
        dihedrals_data = LammpsForceFieldData.get_param_data("dihedrals", dihedral_map, mols, mols_number,
                                             topologies, molid_to_atomid)
        imdihedrals_data = LammpsForceFieldData.get_param_data("imdihedrals", imdihedral_map, mols, mols_number,
                                               topologies, molid_to_atomid)
        lmpd = LammpsData.from_structure(molecule, box_size)
        return LammpsForceFieldData(lmpd.box_size, lmpd.atomic_masses, pair_coeffs, bond_coeffs,
                                    angle_coeffs, dihedral_coeffs, improper_coeffs, atoms_data,
                                    bonds_data, angles_data, dihedrals_data, imdihedrals_data)

    @staticmethod
    def from_amber(mols, mols_number, box_size, packed_molecule, gaussian_files):
        """
        WARNING: The antechamber interface is messed up.

        Use the gaussian output file and the Antechamber tool to generate the
        force field and the topology data for the lammps calculation.

        Args:
            gaussian_files (list): list of gaussian output filenames, one for
                each molecule in the mols list.
        """
        acr = AntechamberRunner(mols)
        amber_ffs = acr.get_gaussian_ff_top(gaussian_files)
        topologies = [amber_ff.topology for amber_ff in amber_ffs]
        forcefields = [amber_ff.force_field for amber_ff in amber_ffs]
        return LammpsForceFieldData(mols, mols_number, box_size, packed_molecule, forcefields,
                                    topologies)


def get_boxed_molecule(molecule, box_size):
    box_lengths = [box_size[dim + 3] - box_size[dim] for dim in range(3)]
    # be defensive about the box size
    if isinstance(molecule, Molecule):
        boxed_molecule = molecule.get_boxed_structure(*box_lengths)
    elif isinstance(molecule, Structure):
        max_length = max(molecule.lattice.abc)
        max_box_size = max(box_lengths)
        boxed_molecule = Molecule.from_sites(molecule.sites)
        if max_length < max_box_size:
            boxed_molecule = \
                boxed_molecule.get_boxed_structure(*box_lengths)
        else:
            boxed_molecule = \
                boxed_molecule.get_boxed_structure(max_length,
                                                   max_length, max_length)
    else:
        raise ValueError("molecule must be an object of Molecule or "
                         "Structure ")
    return boxed_molecule